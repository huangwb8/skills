# Skills 开发流水线 - 项目指令

你正在 `pipelines/skills/` 中工作：该目录用于开发与维护一组"可复用 Agent Skills"。Codex 和 Claude Code 已统一遵循 **Agent Skills 开放标准**（[agentskills.io](https://agentskills.io)），因此不再需要区分平台。本项目现采用**单一技能库**架构，同一套技能可同时用于 Codex、Claude Code 及其他兼容 Agent Skills 的平台。

## 核心哲学：有机整体更新（Organic Holistic Updates）

本项目的技能迭代遵循**有机整体更新**原则，而非简单的补丁式修补。

### 工程原则基础

有机整体更新建立在以下已被广泛验证的工程原则之上：

| 原则 | 核心思想 | 在技能开发中的体现 |
|------|----------|-------------------|
| **奥卡姆剃刀** | 如无必要，勿增实体 | 优先选择最简单的解决方案；避免过度抽象和过度设计 |
| **KISS** | Keep It Simple, Stupid | 追求极致简洁；工作流优先使用线性流程；避免深层嵌套 |
| **YAGNI** | You Aren't Gonna Need It | 只实现当前明确需要的功能；抵制"为未来可能用到"而添加的设计 |
| **DRY** | Don't Repeat Yourself | 相似逻辑应抽象复用；重复参数应提取到 `config.yaml` |
| **SOLID** | 面向对象设计五大原则 | 每个技能职责单一；对扩展开放（通过 config.yaml），对修改封闭 |
| **关注点分离** | 不同层次逻辑应分离 | YAML（语义接口）→ SKILL.md（执行指令）→ references/（背景知识） |
| **最小惊讶原则** | API 行为应符合用户直觉 | 技能触发、输出格式、错误处理应符合用户自然预期 |
| **早期返回原则** | 尽早返回，减少嵌套 | 工作流前置检查失败时立即返回并提示用户 |

**原则冲突时的决策优先级**：
1. **正确性 > 一切**（技能必须能完成承诺的功能）
2. **简洁性 > 灵活性**（优先选择简单方案）
3. **清晰性 > 性能**（避免为"优化"而牺牲可读性）
4. **扩展性 > 紧凑性**（保留扩展点，但保持核心流程简洁）

### 什么是"有机整体更新"？

**❌ 避免的"补丁式更新"：**
```
用户："加一条规则：输出文件要按日期命名"
AI：在文档末尾添加："2025-12-29 更新：文件按日期命名"
```
这种方式会导致文档变成一堆孤立规则的堆砌，规则之间缺乏协调，逻辑逐渐混乱。

**✅ 倡导的"有机整体更新"：**
```
用户："加一条规则：输出文件要按日期命名"
AI：理解意图 → 定位文件命名规则在工作流中的位置 →
    整合到相关章节（如"输出规范"） →
    检查是否与其他规则冲突 →
    重构该章节以保持内聚性 →
    更新相关示例以保持一致性
```

### 有机更新的操作原则

1. **理解而非记录**：在更新前，先理解用户需求背后的意图和在工作流中的本质作用

2. **定位生态位**：每条规则/要求都应找到其在整个文档结构中的"生态位"——它与其他内容的关系、它服务的目标、它影响的其他部分

3. **协调生长**：更新一个部分时，检查并同步更新相关部分：
   - 更新工作流步骤时，同步更新示例和验证清单
   - 更新输出规范时，同步更新引用该规范的其他章节
   - 更新术语定义时，全局统一替换
   - **更新工作逻辑时，同步更新 YAML frontmatter**（见下文"表头-正文一致性"原则）

4. **保持呼吸感**：文档应该像生物体一样有"呼吸感"——章节之间有逻辑流动，而非割裂的清单。使用过渡语、建立概念间的联系

5. **定期修剪整合**：当某个章节变得过于臃肿时，主动重构：
   - 提取共性到更高层原则
   - 将详细内容移至 `references/` 或 `scripts/`
   - 重新组织章节以反映新的理解

### 表头-正文一致性原则（Frontmatter-Body Alignment）

**YAML frontmatter 不是静态元数据，而是技能的"活语义接口"**。当 skill 的工作逻辑更新时，表头必须同步更新以保持一致性。

**核心规则**：
- **`name` 更新**：当技能核心功能发生重大变化（如从单一功能扩展为多功能平台）时，考虑更新名称
- **`description` 更新**：当工作流、输入、输出发生变更时，同步更新描述以准确反映触发场景
- **`metadata.keywords` 更新**：当新增典型使用场景或专业术语时，补充关键词列表
- **`metadata.short-description` 更新**：当技能的价值主张发生变化时，更新单行概览

**更新流程**：
1. 完成工作逻辑更新后，立即检查 YAML frontmatter
2. 验证 `description` 是否仍准确描述技能的实际功能
3. 验证 `keywords` 是否覆盖了新增的触发场景
4. 如有变更，同步更新表头并确保语义匹配

**典型场景**：
| 工作逻辑变更 | 表头同步更新 |
|-------------|-------------|
| 新增工作流步骤 | 更新 `description` 中的功能描述 |
| 修改输入参数 | 更新 `description` 中的参数说明 |
| 新增输出格式 | 更新 `description` 中的输出描述 |
| 扩展使用场景 | 补充 `metadata.keywords` |
| 调整技能定位 | 更新 `name` 和 `metadata.short-description` |

### 更新时的自检清单

在响应任何"更新/优化/修改"请求时，问自己：

- [ ] **意图理解**：我真正理解了用户想要解决什么问题吗？
- [ ] **生态位定位**：这个更新应该放在文档的哪个位置？它与周围内容的关系是什么？
- [ ] **影响范围**：这个更新会影响其他哪些章节？我是否同步更新了？
- [ ] **冲突检查**：新内容是否与现有规则冲突？如果有，如何协调？
- [ ] **术语一致性**：我是否使用了与文档其他部分一致的术语？
- [ ] **示例同步**：相关示例是否反映了新的规则？
- [ ] **内聚性保持**：更新后，该章节是否仍然围绕一个清晰的核心主题？
- [ ] **表头-正文一致性**：我是否检查并更新了 YAML frontmatter 以反映新的工作逻辑？

### 静态自检 vs 动态测试（重要原则）

**核心原则**：AI 负责静态一致性分析，用户负责动态验证测试。

| AI 的职责（静态自检） | 用户的职责（动态测试） |
|---------------------|---------------------|
| 代码-文档一致性分析 | 运行完整流程验证 |
| 逻辑推演：影响范围识别 | 测试边界情况和错误处理 |
| 结构完整性检查 | 验证与其他技能的协同工作 |
| 术语和引用的一致性 | 最终验收和确认 |

**为什么这样分工？**
- ✅ 静态分析快速且不消耗额外资源
- ✅ AI 擅长识别跨文件的逻辑关联
- ✅ 用户保留对耗时测试的控制权
- ✅ 避免不必要的等待和资源消耗

**静态自检的具体内容**：

1. **代码-文档一致性**：
   - 扫描修改的代码逻辑 → 在 SKILL.md 中找到对应描述 → 是否存在且一致？
   - 扫描 SKILL.md 中的功能描述 → 在代码/scripts/ 中找到实现 → 是否存在且匹配？

2. **影响范围推演**：
   - 我修改的这部分被哪些其他部分引用？
   - 我新增的这个功能是否与其他技能的生态位重叠？
   - 我删除的这个特性是否在其他章节还有残留描述？

3. **跨层次一致性**：
   - YAML metadata.keywords 是否覆盖了正文中的所有使用场景？
   - references/ 中被引用的文件是否实际存在？
   - scripts/ 中调用的文件路径是否与实际文件结构一致？

4. **结构完整性**：
   - SKILL.md 的章节结构是否完整？
   - 必需的文件（scripts/, templates/）是否存在？
   - 内部引用链接是否有效？

**用户手动测试（可选）**：
- [ ] 在新建会话中用触发短语测试技能是否被正确调用
- [ ] 运行技能的完整流程，检查所有输出
- [ ] 测试边界情况和错误处理

### 实施有机更新的心智模型

将每个 Skill 的文档体系视为一个**小型的知识生态系统**：

```
┌─────────────────────────────────────┐
│  YAML Frontmatter                  │  ← 元数据层：技能的"身份证"
│  (name, description, metadata)      │     （影响发现机制）
├─────────────────────────────────────┤
│  SKILL.md 正文                      │  ← 操作层：技能的"操作手册"
│  - 目标与触发条件                    │     （告诉 AI 何时/如何行动）
│  - 核心工作流（分步骤）              │
│  - 输出规范与验证标准                │
├─────────────────────────────────────┤
│  references/                        │  ← 知识层：技能的"知识库"
│  - 详细策略与最佳实践                │     （按需加载，深化理解）
│  - 领域知识与标准                    │
├─────────────────────────────────────┤
│  scripts/                           │  ← 工具层：技能的"工具箱"
│  - 可执行的自动化脚本                │     （提高可靠性/可重复性）
└─────────────────────────────────────┘
```

有机更新意味着：**每一层的变更都要考虑其对其他层的涟漪效应，并主动协调**。

### 示例：有机更新 vs 补丁式更新

**场景**：用户要求"加上引用格式的详细说明"

**❌ 补丁式**：
```markdown
## 产出文件

...（原有内容）...

## 引用格式（2025-12-29 新增）
- 格式一：...
- 格式二：...
```

**✅ 有机更新**：
```markdown
## 产出文件

### 引用规范（Nature Reviews 风格）

本技能采用 Nature Reviews 风格的引用格式，以确保学术规范性和可读性。

**正文引用格式**：
- [具体规则...]

**文末参考文献列表**：
- [具体规则...]

**与其他章节的关系**：
- 本规范与"工作流-检索方案"中的 DOI 优先级一致
- 与"验证清单"中的引用完整性检查相互支持
- 脚本 `scripts/convert_markdown_to_latex_pdf.py` 自动应用此格式
```

## 默认语言

除非用户明确要求英文/双语，始终使用简体中文与用户对话与撰写文档/说明。

## 联网与搜索（如需）

默认优先使用项目内文件（尤其是 `Prompts.md`）与本地上下文；确需联网获取信息时，优先使用本地 SearXNG（如已通过 MCP 配置）。仅当 SearXNG 不足以满足需求时再使用其它联网手段，并说明原因与保留关键链接。

## 目录结构

```
pipelines/skills/
├── Prompts.md          # 工作流与定义（优先级最高）
├── AGENTS.md           # 本文档：项目指令
├── CLAUDE.md           # Claude Code 特定指令（保留用于兼容性）
└── {skill_name}/       # 每个 skill 一个子目录
    ├── SKILL.md        # 必需：技能定义（YAML frontmatter + Markdown）
    ├── README.md       # 推荐：用户使用指南（面向使用者，教授如何触发与提示）
    ├── config.yaml     # 推荐：技能参数配置（集中管理数值/路径/阈值，避免在文档中硬编码）
    ├── scripts/        # 可选：可执行脚本
    ├── references/     # 可选：参考文档
    └── assets/         # 可选：模板/资源文件
```

### 必需与推荐文件说明

| 文件 | 必需性 | 面向对象 | 核心作用 |
|------|-------|---------|---------|
| **SKILL.md** | 必需 | AI | 定义技能的工作流、输入输出、验证标准（执行指令） |
| **README.md** | 推荐 | 用户 | 教用户如何触发技能、如何写提示词、使用示例 |
| **config.yaml** | 推荐 | 维护者 | 集中管理可配置参数（阈值、路径、模板等），提高可维护性 |
| **scripts/** | 可选 | 执行引擎 | 需要确定性可靠性或重复执行的自动化任务 |
| **references/** | 可选 | AI（按需） | 详细策略、标准、领域知识（按需加载） |
| **assets/** | 可选 | 输出生成 | 模板、图标、字体等不加载到上下文的资源文件 |

## Agent Skills 标准规范

### 必需结构

每个 skill 必须包含 `SKILL.md` 文件，格式如下：

```yaml
---
name: skill-name
description: Brief description of what this Skill does and when to use it
---

# Skill Title（Markdown body）

[技能说明、工作流程、使用指南等]
```

### 可选资源

- **`scripts/`**: 可执行代码（Python/Bash 等），用于需要确定性可靠性或重复编写代码的任务
- **`references/`**: 参考文档，按需加载到上下文中
- **`assets/`**: 输出资源文件（模板、图标、字体等），不加载到上下文

### 推荐文件（增强可维护性与可用性）

#### `README.md`（用户使用指南）

**目的**：面向**使用者**，教用户如何触发技能并编写有效的提示词。

**与 SKILL.md 的分工**：
- **SKILL.md**：面向 AI，定义"如何执行"（工作流、输入输出、验证标准）
- **README.md**：面向用户，定义"如何触发和使用"（提示词示例、触发场景、参数说明）

**推荐结构**：

```markdown
# {Skill Name} — 用户使用指南

本 README 面向**使用者**：教你如何触发并正确使用 `{skill_name}` skill。

如果你在编辑/维护该 skill：执行指令与强制规范在 `{skill_name}/SKILL.md`；可配置的数值口径集中在 `{skill_name}/config.yaml`（避免多处重复维护）。

## 快速开始（推荐）

[最简单的触发方式示例]

## 提示词示例（从简单到高级）

### 示例 1：最小可用
[最基础的提示词]

### 示例 2：标准完整
[包含常用参数的提示词]

### 示例 3：高级定制
[专业用户的复杂场景]

## 如何选择合适的提示词？

[决策表格或流程图]

## ❌ 不推荐的写法（反面示例）

[常见错误及其问题说明]

## 配置参数说明

[如果 skill 使用 config.yaml，解释关键参数的含义及修改方式]
```

**有机更新原则**：
- 当 SKILL.md 的工作流更新时，同步更新 README.md 中的示例
- 当新增触发场景时，在 README.md 中补充对应的提示词示例
- 保持示例与实际技能行为的一致性

#### `config.yaml`（参数配置文件）

**目的**：集中管理技能的可配置参数，避免在文档中硬编码数值，提高可维护性。

**优势**：
- **单一真实来源**：参数值只在一个地方定义，避免多处维护
- **易于调整**：修改数值口径无需改动文档内容
- **版本控制友好**：参数变更的 diff 更清晰
- **可程序化访问**：脚本可读取配置文件，实现参数驱动的行为

**适用场景**：
- 数值阈值（如质量评价标准、证据充足性阈值）
- 路径配置（如模板路径、输出目录）
- API 配置（如超时时间、速率限制）
- 领域特定参数（如不同学科的期刊列表、影响因子阈值）

**推荐结构**：

```yaml
# {skill_name} 配置文件
# 说明：集中管理可配置参数，避免在 SKILL.md 中硬编码

# ============================================================================
# 参数类别 1
# ============================================================================

category_name:
  parameter_1: value
  parameter_2: value

# ============================================================================
# 参数类别 2
# ============================================================================

another_category:
  # 参数说明（如适用）
  parameter_with_note: value
```

**有机更新原则**：
- 新增可配置参数时，在 config.yaml 中添加，同时在 SKILL.md 中引用（不硬编码值）
- 修改参数口径时，只需更新 config.yaml，确保 SKILL.md 中的引用保持一致
- 参数删除或重命名时，检查 SKILL.md 和 scripts/ 中的引用并同步更新

**示例**（来自 `systematic-literature-review`）：

```yaml
# 证据充足性阈值
evidence:
  min_candidates: 300
  min_tier1_tier2: 80
  min_per_subtopic: 8
```

在 SKILL.md 中引用时：
```markdown
## 证据充足性判断

根据 `config.yaml` 中 `evidence` 配置的阈值：
- 候选文献总量 ≥ `evidence.min_candidates`
- Tier 1 + Tier 2 ≥ `evidence.min_tier1_tier2`
- 每子主题 ≥ `evidence.min_per_subtopic`
```

而非硬编码：
```markdown
## 证据充足性判断

候选文献总量 ≥ 300
Tier 1 + Tier 2 ≥ 80
每子主题 ≥ 8
```

### 核心原则

#### 1. 简洁至上 (Concise is Key)

**上下文窗口是公共资源**。启动时只加载所有 Skills 的 metadata（name 和 description），SKILL.md 主体按需加载。

**编写时的自我拷问**：
- "Claude 真的需要这个解释吗？"
- "我能假设 Claude 已经知道这个吗？"
- "这个段落值得消耗这些 token 吗？"

**示例对比**：
```markdown
<!-- ✅ 好：简洁 (~50 tokens) -->
## Extract PDF text
Use pdfplumber for text extraction:
```python
import pdfplumber
with pdfplumber.open("file.pdf") as pdf:
    text = pdf.pages[0].extract_text()
```

<!-- ❌ 差：冗长 (~150 tokens) -->
## Extract PDF text
PDF (Portable Document Format) files are a common file format...
To extract text from a PDF, you'll need to use a library...
[冗长的安装说明和基础解释...]
```

#### 2. 适度自由度原则 (Degrees of Freedom)

根据任务的脆弱性和可变性匹配指令的精确度：

| 自由度 | 适用场景 | 指令形式 |
|--------|----------|----------|
| **高自由度** | 多种有效路径、依赖上下文判断 | 文本指导 + 启发式规则 |
| **中自由度** | 有首选模式但可变通 | 伪代码 + 可配置参数 |
| **低自由度** | 操作脆弱、一致性关键 | 精确脚本 + 严格步骤 |

**类比**：想象 Claude 在探路
- **悬崖边的窄桥**：只有一条安全路径 → 提供具体护栏（低自由度）
- **开阔的平原**：多条路径可达目标 → 给出大致方向（高自由度）

#### 3. 渐进式披露 (Progressive Disclosure)

**SKILL.md 是概览/导航，不是百科全书**。将详细内容分离到独立文件，按需加载。

**三层结构**：
```
启动时加载 → SKILL.md（触发时）
按需加载 → reference/*.md（需要时）
从不加载 → scripts/（执行，不读内容）
```

#### 4. 工作流与反馈循环

**复杂任务工作流**：提供清晰的顺序步骤，对特别复杂的工作流提供清单

**验证器循环**：运行验证器 → 修复错误 → 重复

**示例模式**：
- **模板模式**：严格需求（如 API 响应）vs 灵活指导
- **示例模式**：提供输入/输出对

## 新建/更新 skill 的默认流程（遵循有机更新原则）

### 1. 需求确认阶段

1. 阅读 `Prompts.md`，确认本次需求是否属于"创建/优化 skill"
2. 获取并确认 `skill_name`：
   - 用户不能提供且也不同意你自取名字：终止
   - 用户允许你自取：给出 1–3 个候选并确认后再创建目录

### 2. 创建阶段（初次构建知识生态）

在 `{skill_name}/` 创建技能时，**从一开始就建立有机结构**：

- **创建 `SKILL.md`（必需）**：
  - 以 YAML frontmatter 定义技能的"身份证"（发现机制）
  - 以清晰的章节结构定义工作流、输入、输出、验证标准
  - 在各章节间建立逻辑联系（使用过渡语、引用关系）

- **按需添加支撑结构**：
  - `scripts/`：将重复性代码或需要确定性的操作脚本化
  - `references/`：将详细策略、领域知识、标准文档独立存放
  - `assets/`：将模板、图标等资源文件独立管理

**关键**：创建时就考虑"未来更新时，新内容应该放在哪里"，预留下合理的扩展点。

### 3. 更新阶段（有机生长）

当用户提出优化建议时，执行**有机更新流程**：

1. **理解意图**：用户真正想解决什么问题？（而非字面要求）

2. **生态位定位**：
   - 这个更新应该放在哪个层级？（YAML / SKILL.md 正文 / references / scripts）
   - 它与现有内容的关系是什么？（补充、修正、重构、扩展）

3. **影响分析**：
   - 这个更新会影响哪些其他部分？
   - 是否需要同步更新示例、验证清单、相关引用？

4. **执行更新**：
   - 将新内容整合到合适的位置（而非简单追加）
   - 调整周围内容以保持内聚性
   - 更新术语和示例以保持一致性
   - 必要时重构章节结构以反映新的理解

5. **验证完整性**：
   - 使用前述"更新时的自检清单"验证
   - 确保文档仍然是一个有机整体，而非规则碎片集合

### 有机更新的典型场景示例

| 场景 | 补丁式（❌） | 有机式（✅） |
|------|-------------|-------------|
| 用户要求增加新的输入参数 | 在"你需要确认的输入"末尾追加 | 重新审视整个输入框架，将新参数整合到逻辑分组，更新所有依赖该参数的工作流步骤 |
| 用户要求修改输出格式 | 仅修改"输出规范"部分 | 同步更新：示例、验证清单、相关脚本、references 中涉及该格式的说明 |
| 用户要求增加新的工作流步骤 | 在步骤列表末尾追加 | 分析新步骤与现有步骤的关系，重新组织工作流的叙述逻辑，更新流程图和交叉引用 |
| 用户要求删除某条规则 | 直接删除该行 | 检查是否有其他内容依赖该规则，更新相关章节，确保删除后逻辑仍然完整 |

## 本机可发现性（系统级安装）

本仓库的 skills 默认只在“当前 workdir 位于本仓库”时更容易被发现；要确保它们在**任意项目/对话**里都可用，需要将 skills **复制安装**到系统级目录（不使用软链接）。

### 一键安装（推荐）

触发并执行 `install-bensz-skills`：

```bash
python3 install-bensz-skills/scripts/install.py
```

> 说明：该脚本会把 `pipelines/skills/` 下的所有 skills 安装到 `~/.codex/skills/` 与 `~/.claude/skills/`，并自动备份/替换同名旧版本；不会安装 `install-bensz-skills` 自身。

### 验证技能可用性

在任意目录执行：

```bash
codex exec "列出所有可用的技能"
```

Claude Code：建议新建会话后验证触发（技能在会话启动时加载）。

## 兼容的平台

根据 [Agent Skills 官方网站](https://agentskills.io)，以下平台支持该标准：

- ✅ Claude Code
- ✅ OpenAI Codex
- ✅ Cursor
- ✅ GitHub
- ✅ VS Code
- ✅ Amp
- ✅ Letta
- ✅ Goose

## 变更边界

- 只修改 `pipelines/skills/` 内文件，除非用户明确授权扩展到其它目录
- 不批量重写与当前任务无关的文档与结构；保持最小可用、可迭代

## 交付检查清单（有机更新视角）

完成技能创建或更新后，使用以下清单验证**文档的有机性和完整性**：

### 结构完整性（Structure Integrity）

- [ ] `Prompts.md` 的流程是否仍然成立（或已同步更新并得到用户确认）
- [ ] `skills/` 下的 skill 是否符合 Agent Skills 标准
- [ ] `SKILL.md` 是否包含必需的 YAML frontmatter（`name` 和 `description`）
- [ ] YAML frontmatter 是否准确反映当前的工作逻辑（表头-正文一致性）
- [ ] **推荐文件完整性**：如适用，是否包含 `README.md`（用户指南）和 `config.yaml`（参数配置）？

### 有机性验证（Organic Integrity）

- [ ] **章节内聚性**：每个章节是否围绕一个清晰的核心主题？
- [ ] **逻辑流动性**：章节之间是否有明确的逻辑关系和过渡？（而非割裂的清单）
- [ ] **术语一致性**：全文是否使用一致的术语体系？
- [ ] **引用完整性**：章节间的相互引用是否准确且双向一致？
- [ ] **示例同步性**：示例是否反映了当前的所有规则？

### 静态一致性检查（AI 自动执行）

- [ ] **代码-文档一致性**：修改的代码逻辑在 SKILL.md 中有对应描述
- [ ] **跨层次一致性**：YAML keywords 覆盖了正文中的使用场景；references/ 引用存在
- [ ] **影响范围检查**：无孤立修改或遗漏的同步更新
- [ ] **结构完整性**：必需文件存在，内部引用链接有效
- [ ] **参数配置一致性**：如存在 `config.yaml`，SKILL.md 中的参数引用是否与 config.yaml 保持一致？（而非硬编码）

### 内容质量检查

#### YAML Frontmatter 质量
- [ ] `name` 是否采用动名词形式且符合命名规范？
- [ ] `description` 是否具体且包含"做什么"和"何时用"两个要素？
- [ ] `description` 是否使用第三人称？
- [ ] `metadata.keywords` 是否覆盖主要触发场景？

#### SKILL.md 内容组织
- [ ] **长度控制**：SKILL.md 主体是否在 500 行以内？
- [ ] **避免深层嵌套**：所有引用文件是否直接从 SKILL.md 链接？
- [ ] **长文件目录**：超过 100 行的参考文件是否在顶部添加了目录？
- [ ] **工作流清晰度**：复杂任务是否提供了清单或步骤说明？

#### 反模式检查
- [ ] **避免启动时加载所有内容**：是否遵循 lazy loading？
- [ ] **避免模糊描述**：`description` 是否具体且包含关键术语？
- [ ] **避免提供太多选项**：是否提供默认方案而非罗列多个选择？
- [ ] **避免假设工具已安装**：是否明确列出所需包？
- [ ] **避免时间敏感信息**：是否使用"旧模式"部分处理过时内容？

### 技术支撑验证（Technical Support）

- [ ] 如引入脚本：提供最小可运行示例与使用说明，且脚本与文档描述一致
- [ ] 如添加 references：与 SKILL.md 正文的交叉引用清晰明确
- [ ] 如需联网：是否已优先使用 SearXNG，且已记录关键来源链接/结论依据
- [ ] **脚本质量**：是否显式处理错误而非推诿给 Claude？
- [ ] **避免魔法数字**：所有常量是否有注释解释？
- [ ] **路径规范**：是否始终使用正斜杠？
- [ ] **MCP 工具引用**：是否使用完全限定名称？

### 更新历史审视（Update History Review）

- [ ] 检查最近 3-5 次更新：是否采用了有机更新方式？
- [ ] 是否存在孤立追加的规则？如果有，考虑是否需要重构整合
- [ ] 是否存在章节臃肿、需要拆分或提取到 references/ 的部分？

### 生态系统验证（Ecosystem Verification）

- [ ] 四层结构（YAML / 正文 / references / scripts）是否各司其职？
- [ ] Progressive Disclosure 原则是否得到体现？（元数据 → 正文 → 详细资源）
- [ ] 技能是否可以在"只读元数据"状态下被正确发现和理解？

---

> **注意**：本清单中的所有检查项均为**静态分析**，不涉及实际运行测试。动态验证测试由用户根据需要手动执行。
