---
name: auto-test-skill
version: 1.0.0
category: normal
metadata:
  short-description: 自动化测试驱动优化工作流
  keywords:
    - testing
    - quality assurance
    - bug tracking
    - test-driven development
    - iteration
    - optimization
    - testing workflow
    - regression testing
  author: bensz
  created: '2026-01-02'
  tags:
    - testing
    - workflow
    - automation
    - quality
description: |
  自动化测试驱动优化技能 - 用于AI辅助开发后的系统性测试和迭代优化。

  **核心能力**:
  - 根据用户开发实例的测试结果,生成结构化的问题报告
  - 制定step-by-step的优化计划和轻量测试计划
  - 引导优化-测试-发现bug-修复bug-再优化的循环流程
  - 管理测试会话,确保所有测试过程透明化、规范化、可重复化
  - 生成测试总结文档,记录修复历程和最终验收结果

  **何时使用**:
  - 用户完成AI辅助开发后,需要进行系统性测试
  - 发现bug需要记录和优先级排序
  - 需要制定结构化的优化和测试计划
  - 需要管理多轮迭代测试和修复流程
  - 需要生成规范的测试报告和总结文档

  **输入要求**:
  - 目标技能的根目录路径
  - 测试发现的问题列表(可来自用户反馈、测试结果、代码审查等)
  - 可选:已有测试数据或测试用例

  **输出交付**:
  - 结构化的问题报告(bug详情、优先级、修复建议)
  - 详细的优化计划(step-by-step)
  - 轻量测试计划(验证点、预期结果)
  - 测试会话目录(包含TEST_PLAN.md、TEST_REPORT.md等)
  - 最终测试总结和验收报告
---

# 自动化测试驱动优化技能

## 概述

本技能提供了一套完整的测试驱动优化工作流,帮助用户在AI辅助开发后进行系统性的测试、问题修复和迭代优化。

**核心价值**:
- ✅ **结构化问题管理**: 从bug发现到优先级排序的全流程管理
- ✅ **可重复测试**: 规范化的测试目录和文档结构
- ✅ **渐进式优化**: 通过轻量测试快速验证修复效果
- ✅ **完整追溯**: 每轮迭代都有明确的测试计划和报告

**设计理念**:
本技能借鉴了成熟的软件测试实践(如时间戳命名测试会话、规范化文档结构、测试数据/脚本/输出分离等),确保每个测试会话都是独立、透明、可重复的。

---

## 工作流程

### 阶段 1: 问题收集与分析

**目标**: 将用户发现的问题整理为结构化的问题报告

**输入**:
- 用户反馈的问题描述
- 测试输出结果
- 代码审查发现
- 任何其他问题来源

**输出**: `BUG_REPORT.md`

**问题报告结构**:
```markdown
# Bug报告: [项目名称]

## 问题概述
- 测试时间
- 测试环境
- 问题总数
- 严重程度分布

## 问题清单

### 问题 #1: [简短标题]
**严重程度**: Critical / High / Medium / Low
**优先级**: P0 / P1 / P2 / P3
**状态**: Open / Fixed / Verified

**问题描述**:
- 现象描述
- 复现步骤
- 实际行为 vs 期望行为
- 影响范围

**根因分析**:
- 问题根源
- 相关代码/文件
- 为什么会出现

**修复建议**:
- 推荐方案
- 替代方案
- 预期效果

**验证方法**:
- 如何验证修复
- 测试用例
- 预期结果

---

(重复上述结构,列出所有问题)
```

**优先级定义**:

| 优先级 | 定义 | 响应时间 | 示例 |
|--------|------|----------|------|
| **P0** | 阻塞性问题,完全无法使用 | 立即修复 | 程序崩溃、数据丢失 |
| **P1** | 严重问题,核心功能受影响 | 24小时内 | 主要功能失效、安全漏洞 |
| **P2** | 中等问题,部分功能受限 | 3天内 | 边缘场景错误、UI异常 |
| **P3** | 轻微问题,不影响主要功能 | 1周内 | 文档错误、体验优化 |

---

### 阶段 2: 优化计划制定

**目标**: 为当前迭代制定详细的优化和测试计划

**输入**:
- BUG_REPORT.md
- 可用的修复时间/资源
- 技术约束条件

**输出**: `OPTIMIZATION_PLAN.md`

**优化计划结构**:
```markdown
# 优化计划: [项目名称] v[版本号]

## 计划概述
- 迭代目标
- 预期成果
- 时间估算
- 风险评估

## 迭代范围

### 本次迭代修复的问题
- [ ] 问题 #1 (P0)
- [ ] 问题 #5 (P1)
- ...

### 本次迭代暂缓的问题
- 问题 #3 (P2) - 原因: ...
- 问题 #8 (P3) - 原因: ...

## Step-by-Step 修复步骤

### 步骤 1: [修复问题 #1]
**文件**: `path/to/file.py`
**方法**: `method_name()`
**行号**: 123-145

**修改内容**:
\`\`\`python
# 修改前
...

# 修改后
...
\`\`\`

**验证方法**:
- 测试用例: ...
- 预期结果: ...

---

(重复上述结构,列出所有修复步骤)

## 测试计划

### 测试用例 1: [验证问题 #1修复]
**测试场景**: ...
**输入**: ...
**预期输出**: ...
**验证点**: ...

---

(重复上述结构,列出所有测试用例)

## 验收标准
- [ ] 所有P0问题已修复
- [ ] 所有P1问题已修复
- [ ] 测试用例100%通过
- [ ] 无回归问题
- [ ] 文档已更新
```

---

### 阶段 3: 测试会话管理

**目标**: 创建结构化的测试会话目录,确保测试过程可追溯

**输入**:
- OPTIMIZATION_PLAN.md
- 目标技能根目录

**输出**: 测试会话目录结构

**测试会话命名规则**:
- 格式: `vYYYYMMDDHHMM`
- 示例: `v202601021313`
- 保证按时间顺序排列

**目录结构**:
```
{项目根目录}/test/v{YYYYMMDDHHMM}/
├── TEST_PLAN.md           # 测试计划(阶段2输出)
├── TEST_REPORT.md         # 测试报告(阶段5填写)
├── README.md              # Step-by-Step操作指南(可选)
├── SUMMARY.md             # 快速总览(可选)
├── BUG_REPORT.md          # Bug报告(阶段1输出)
├── OPTIMIZATION_PLAN.md   # 优化计划(阶段2输出)
├── data/                  # 测试数据
│   ├── input1.json
│   └── test_cases.yaml
├── scripts/               # 测试脚本
│   ├── test_fix_1.py
│   ├── test_fix_2.py
│   └── validate_all.py
└── output/                # 测试输出
    ├── results.json
    ├── logs/
    └── artifacts/
```

**创建测试会话**:
1. 在目标项目的 `test/` 目录下创建新的测试会话目录
2. 复制 BUG_REPORT.md 和 OPTIMIZATION_PLAN.md
3. 创建 data/ 和 scripts/ 子目录
4. 准备测试数据和测试脚本

---

### 阶段 4: 执行优化与测试

**目标**: 按照优化计划执行修复,并通过测试验证效果

**输入**:
- OPTIMIZATION_PLAN.md
- 测试数据和脚本

**输出**: 修复后的代码 + 测试结果

**执行流程**:
```bash
# 进入测试会话目录
cd test/v{YYYYMMDDHHMM}

# 1. 阅读优化计划
cat OPTIMIZATION_PLAN.md

# 2. 执行修复步骤(按顺序)
# 步骤1: 修复问题 #1
# 步骤2: 修复问题 #5
# ...

# 3. 运行测试脚本
python3 scripts/test_fix_1.py
python3 scripts/test_fix_2.py
python3 scripts/validate_all.py

# 4. 检查测试输出
ls output/
cat output/results.json
```

**修复原则**:
- ✅ **KISS**: 优先选择最简单的修复方案
- ✅ **单一职责**: 每次修复只解决一个问题
- ✅ **测试驱动**: 先写测试用例,再修复代码
- ✅ **渐进验证**: 每修复一个问题立即验证

**测试原则**:
- ✅ **快速反馈**: 测试应该在几秒内完成
- ✅ **独立性**: 每个测试用例相互独立
- ✅ **可重复性**: 测试结果应该稳定可重复
- ✅ **自动化**: 尽可能自动化测试执行

---

### 阶段 5: 测试报告与总结

**目标**: 记录测试结果,验证修复效果,决定是否进入下一轮迭代

**输入**:
- 测试执行结果
- 验证点检查结果

**输出**: `TEST_REPORT.md`

**测试报告结构**:
```markdown
# 测试报告: [项目名称] v[版本号]

**测试时间**: 2026-01-02 14:30
**测试环境**: ...
**测试状态**: ✅ 通过 / ❌ 失败 / ⚠️ 部分通过

## 执行摘要

### 修复统计
- 计划修复问题数: X
- 成功修复问题数: Y
- 修复成功率: Z%
- 发现新问题数: N

### 测试统计
- 测试用例总数: X
- 通过用例数: Y
- 失败用例数: Z
- 测试通过率: P%

## 问题修复详情

### 问题 #1: [标题]
**状态**: ✅ 已修复 / ❌ 未修复 / ⚠️ 部分修复

**修复内容**:
- 修改文件: ...
- 修改内容: ...

**验证结果**:
- 测试用例: ...
- 实际结果: ...
- 预期结果: ...
- 结论: 通过/失败

**截图/日志**:
\`\`\`
测试输出...
\`\`\`

---

(重复上述结构,列出所有问题的修复情况)

## 测试用例结果

### 测试用例 1: [名称]
**状态**: ✅ 通过 / ❌ 失败

**输入**: ...
**预期输出**: ...
**实际输出**: ...
**差异说明**: ...

---

(重复上述结构,列出所有测试用例)

## 发现的新问题

### 新问题 #N+1: [标题]
**严重程度**: ...
**描述**: ...
**建议处理**: 下次迭代 / 立即修复

---

## 回归测试结果

### 已修复问题验证
- [ ] 问题 #1: ✅ 无回归
- [ ] 问题 #5: ✅ 无回归
- ...

### 功能完整性检查
- [ ] 核心功能正常
- [ ] 边缘场景正常
- [ ] 性能未退化
- [ ] 兼容性保持

## 下一步行动

### 如果测试通过
1. 更新 CHANGELOG.md
2. 更新相关文档
3. 合并代码到主分支
4. 归档测试会话

### 如果测试失败
1. 分析失败原因
2. 更新优化计划
3. 进入下一轮迭代
4. 创建新的测试会话目录

## 附录

### 测试环境详情
- 操作系统: ...
- Python版本: ...
- 依赖包版本: ...

### 测试数据清单
- input1.json (X KB)
- test_cases.yaml (Y KB)

### 测试脚本清单
- test_fix_1.py
- test_fix_2.py
- validate_all.py
```

**测试状态定义**:

| 状态 | 含义 | 后续行动 |
|------|------|----------|
| ✅ 通过 | 所有问题已修复,所有测试通过 | 更新文档,合并代码 |
| ❌ 失败 | 关键问题未修复或测试失败 | 分析原因,创建新测试会话 |
| ⚠️ 部分通过 | 非关键问题未修复或部分测试失败 | 评估风险,决定是否继续 |

---

### 阶段 6: 迭代循环或结束

**判断依据**:

**满足以下条件时,结束优化流程**:
- ✅ 所有 P0 和 P1 问题已修复
- ✅ 核心功能测试100%通过
- ✅ 无回归问题
- ✅ 文档已更新

**否则,进入下一轮迭代**:
1. 将未修复的问题和新发现的问题整理到新的 BUG_REPORT.md
2. 制定新的 OPTIMIZATION_PLAN.md
3. 创建新的测试会话目录 `v{新时间戳}`
4. 重复阶段 4-5

**最终总结**:
当优化流程结束时,生成 `FINAL_SUMMARY.md`:
```markdown
# 优化总结: [项目名称]

## 优化历程
- 起始时间: 2026-01-02
- 结束时间: 2026-01-05
- 迭代轮数: 3
- 测试会话: v202601021313, v202601031015, v202601041420

## 问题修复统计
- 初始问题数: X
- 修复问题数: Y
- 新增问题数: Z
- 最终问题数: W

## 质量改进
- 测试覆盖率: X% → Y%
- Bug密度: X/KLOC → Y/KLOC
- 用户满意度: ...

## 经验教训
- 做得好的地方: ...
- 需要改进的地方: ...
- 下次优化建议: ...
```

---

## 配置文件

本技能使用 `config.yaml` 配置测试参数:

```yaml
# 测试会话配置
test_session:
  # 测试目录名称(相对于项目根目录)
  directory: "test"
  # 时间戳格式
  timestamp_format: "%Y%m%d%H%M"
  # 最大迭代轮数(默认10轮,防止无限循环)
  max_iterations: 10

# 问题优先级配置
priority:
  # P0问题的自动响应(可选)
  auto_fix_p0: false
  # 每轮迭代最大修复问题数
  max_fixes_per_iteration: 5

# 测试配置
testing:
  # 默认测试超时(秒)
  timeout: 30
  # 测试失败时是否自动停止
  stop_on_failure: true
  # 是否生成详细日志
  verbose_logging: true

# 报告配置
reporting:
  # 是否生成HTML报告(可选)
  html_report: false
  # 是否生成图表(可选)
  generate_charts: false
  # 报告语言
  language: "zh-CN"
```

---

## 最佳实践

### 1. 问题分类原则

**严重程度判断标准**:

| 严重程度 | 判断问题 |
|----------|----------|
| **Critical** | 数据丢失、安全漏洞、完全无法使用 |
| **High** | 主要功能失效、性能严重退化、用户体验严重受损 |
| **Medium** | 边缘功能失效、性能轻微退化、用户体验一般受损 |
| **Low** | 文档错误、UI瑕疵、体验优化建议 |

### 2. 迭代计划原则

**每次迭代应该**:
- ✅ 专注修复少量高优先级问题(3-5个)
- ✅ 确保每个修复都有对应的测试
- ✅ 验证无回归后再合并

**每次迭代不应该**:
- ❌ 试图修复所有问题
- ❌ 修复没有测试的问题
- ❌ 引入新的破坏性变更

### 3. 测试设计原则

**好的测试用例**:
- ✅ 快速执行(几秒内)
- ✅ 独立运行(不依赖顺序)
- ✅ 结果明确(通过/失败清晰)
- ✅ 可重复执行(结果稳定)

**测试用例模板**:
```python
def test_fix_problem_1():
    """测试问题#1的修复效果"""
    # Arrange
    input_data = {...}

    # Act
    result = function_to_test(input_data)

    # Assert
    assert result == expected_output
```

### 4. 文档管理原则

**测试文档应该**:
- ✅ 简洁明了(重点信息突出)
- ✅ 结构一致(使用统一模板)
- ✅ 及时更新(每个阶段结束后立即更新)
- ✅ 独立完整(不依赖外部文档)

---

## 常见问题

### Q1: 如果测试会话太多怎么办?

**A**: 测试会话目录本身就很轻量(主要是文档),可以保留所有历史会话。如果需要清理,建议:
- 保留最近10个会话
- 归档早期的会话到 `test_archive/`
- 保留关键里程碑的会话(如首次完整测试、重大修复等)

### Q2: 如果一个问题需要多轮迭代才能修复怎么办?

**A**:
- 在第一轮迭代中,尝试最小化修复(缓解问题而非完美解决)
- 在后续迭代中,逐步完善修复
- 在 BUG_REPORT.md 中标记问题的演进历史

### Q3: 如果在修复过程中引入新问题怎么办?

**A**:
- 立即记录新问题到 BUG_REPORT.md
- 评估新问题的严重程度
- 如果是 P0/P1,停止当前修复,优先处理新问题
- 如果是 P2/P3,记录到下次迭代计划

### Q4: 如何确保测试的轻量级?

**A**:
- 优先使用单元测试而非集成测试
- 使用 mock/stub 隔离外部依赖
- 测试数据尽量小而精
- 避免耗时操作(如网络请求、文件IO)

---

## 示例使用场景

### 场景 1: 修复技能的 Bug

**输入**:
- 用户报告某个技能的3个bug
- 技能根目录: `/path/to/skills/your-skill`

**执行流程**:
1. 阶段1: 生成 BUG_REPORT.md
2. 阶段2: 制定 OPTIMIZATION_PLAN.md(计划修复P0和P1问题)
3. 阶段3: 创建测试会话 `test/v202601021313/`
4. 阶段4: 执行修复,运行测试
5. 阶段5: 填写 TEST_REPORT.md
6. 阶段6: 验证通过,更新文档

**输出**:
- 修复后的代码
- 完整的测试文档
- CHANGELOG.md 更新

### 场景 2: 多轮迭代优化

**背景**: 第一次测试发现10个问题,计划分3轮迭代

**迭代轮次**:
- **第1轮** (`v202601021313`): 修复 P0(2个) + P1(3个) → 测试通过
- **第2轮** (`v202601031015`): 修复 P2(3个) → 测试通过
- **第3轮** (`v202601041420`): 修复 P3(2个) + 新发现的问题 → 测试通过

**最终输出**:
- FINAL_SUMMARY.md(总结3轮优化历程)
- 所有问题已修复
- 测试覆盖率提升

---

## 参考资源

- **配置文件**: [config.yaml](./config.yaml)
- **文档模板**: [templates/](./templates/)
- **Agent Skills标准**: [https://agentskills.io](https://agentskills.io)

**相关阅读**:
- 测试驱动开发(TDD)最佳实践
- 敏捷开发中的迭代优化方法
- 软件质量保证(SQA)标准流程

---

## 附录: 模板文件

### A. BUG_REPORT.md 模板

见阶段1的问题报告结构

### B. OPTIMIZATION_PLAN.md 模板

见阶段2的优化计划结构

### C. TEST_REPORT.md 模板

见阶段5的测试报告结构

### D. FINAL_SUMMARY.md 模板

见阶段6的最终总结结构
